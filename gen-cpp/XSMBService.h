/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef XSMBService_H
#define XSMBService_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "LinuxFileClient_types.h"

namespace azure { namespace storage { namespace linuxFileClient {

#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class XSMBServiceIf {
 public:
  virtual ~XSMBServiceIf() {}
  virtual bool CreateDirectory(const std::string& dirPath) = 0;
  virtual bool DeleteDirectory(const std::string& dirPath, const bool isRecursive) = 0;
  virtual bool CreateFile(const std::string& filePath, const int64_t fileSize, const bool noBuffering) = 0;
  virtual bool DeleteFile(const std::string& filePath) = 0;
  virtual bool ReadFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName) = 0;
  virtual bool WriteFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName) = 0;
  virtual bool ListCloudFiles(const std::string& dirPath, const bool isRecursive, const std::map<std::string, MatchInformation::type> & files, const std::map<std::string, MatchInformation::type> & dirs) = 0;
  virtual int64_t GetCloudFileLength(const std::string& filePath) = 0;
  virtual bool SetCloudFileLength(const std::string& filePath, const int64_t fileLength) = 0;
};

class XSMBServiceIfFactory {
 public:
  typedef XSMBServiceIf Handler;

  virtual ~XSMBServiceIfFactory() {}

  virtual XSMBServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(XSMBServiceIf* /* handler */) = 0;
};

class XSMBServiceIfSingletonFactory : virtual public XSMBServiceIfFactory {
 public:
  XSMBServiceIfSingletonFactory(const boost::shared_ptr<XSMBServiceIf>& iface) : iface_(iface) {}
  virtual ~XSMBServiceIfSingletonFactory() {}

  virtual XSMBServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(XSMBServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<XSMBServiceIf> iface_;
};

class XSMBServiceNull : virtual public XSMBServiceIf {
 public:
  virtual ~XSMBServiceNull() {}
  bool CreateDirectory(const std::string& /* dirPath */) {
    bool _return = false;
    return _return;
  }
  bool DeleteDirectory(const std::string& /* dirPath */, const bool /* isRecursive */) {
    bool _return = false;
    return _return;
  }
  bool CreateFile(const std::string& /* filePath */, const int64_t /* fileSize */, const bool /* noBuffering */) {
    bool _return = false;
    return _return;
  }
  bool DeleteFile(const std::string& /* filePath */) {
    bool _return = false;
    return _return;
  }
  bool ReadFile(const std::string& /* filePath */, const StreamDataLayout& /* data */, const bool /* noBuffering */, const int8_t /* fileVersion */, const bool /* useVersionInData */, const std::string& /* keyName */) {
    bool _return = false;
    return _return;
  }
  bool WriteFile(const std::string& /* filePath */, const StreamDataLayout& /* data */, const bool /* noBuffering */, const int8_t /* fileVersion */, const bool /* useVersionInData */, const std::string& /* keyName */) {
    bool _return = false;
    return _return;
  }
  bool ListCloudFiles(const std::string& /* dirPath */, const bool /* isRecursive */, const std::map<std::string, MatchInformation::type> & /* files */, const std::map<std::string, MatchInformation::type> & /* dirs */) {
    bool _return = false;
    return _return;
  }
  int64_t GetCloudFileLength(const std::string& /* filePath */) {
    int64_t _return = 0;
    return _return;
  }
  bool SetCloudFileLength(const std::string& /* filePath */, const int64_t /* fileLength */) {
    bool _return = false;
    return _return;
  }
};

typedef struct _XSMBService_CreateDirectory_args__isset {
  _XSMBService_CreateDirectory_args__isset() : dirPath(false) {}
  bool dirPath :1;
} _XSMBService_CreateDirectory_args__isset;

class XSMBService_CreateDirectory_args {
 public:

  XSMBService_CreateDirectory_args(const XSMBService_CreateDirectory_args&);
  XSMBService_CreateDirectory_args& operator=(const XSMBService_CreateDirectory_args&);
  XSMBService_CreateDirectory_args() : dirPath() {
  }

  virtual ~XSMBService_CreateDirectory_args() throw();
  std::string dirPath;

  _XSMBService_CreateDirectory_args__isset __isset;

  void __set_dirPath(const std::string& val);

  bool operator == (const XSMBService_CreateDirectory_args & rhs) const
  {
    if (!(dirPath == rhs.dirPath))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateDirectory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateDirectory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class XSMBService_CreateDirectory_pargs {
 public:


  virtual ~XSMBService_CreateDirectory_pargs() throw();
  const std::string* dirPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_CreateDirectory_result__isset {
  _XSMBService_CreateDirectory_result__isset() : success(false) {}
  bool success :1;
} _XSMBService_CreateDirectory_result__isset;

class XSMBService_CreateDirectory_result {
 public:

  XSMBService_CreateDirectory_result(const XSMBService_CreateDirectory_result&);
  XSMBService_CreateDirectory_result& operator=(const XSMBService_CreateDirectory_result&);
  XSMBService_CreateDirectory_result() : success(0) {
  }

  virtual ~XSMBService_CreateDirectory_result() throw();
  bool success;

  _XSMBService_CreateDirectory_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const XSMBService_CreateDirectory_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateDirectory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateDirectory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_CreateDirectory_presult__isset {
  _XSMBService_CreateDirectory_presult__isset() : success(false) {}
  bool success :1;
} _XSMBService_CreateDirectory_presult__isset;

class XSMBService_CreateDirectory_presult {
 public:


  virtual ~XSMBService_CreateDirectory_presult() throw();
  bool* success;

  _XSMBService_CreateDirectory_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _XSMBService_DeleteDirectory_args__isset {
  _XSMBService_DeleteDirectory_args__isset() : dirPath(false), isRecursive(false) {}
  bool dirPath :1;
  bool isRecursive :1;
} _XSMBService_DeleteDirectory_args__isset;

class XSMBService_DeleteDirectory_args {
 public:

  XSMBService_DeleteDirectory_args(const XSMBService_DeleteDirectory_args&);
  XSMBService_DeleteDirectory_args& operator=(const XSMBService_DeleteDirectory_args&);
  XSMBService_DeleteDirectory_args() : dirPath(), isRecursive(0) {
  }

  virtual ~XSMBService_DeleteDirectory_args() throw();
  std::string dirPath;
  bool isRecursive;

  _XSMBService_DeleteDirectory_args__isset __isset;

  void __set_dirPath(const std::string& val);

  void __set_isRecursive(const bool val);

  bool operator == (const XSMBService_DeleteDirectory_args & rhs) const
  {
    if (!(dirPath == rhs.dirPath))
      return false;
    if (!(isRecursive == rhs.isRecursive))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteDirectory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteDirectory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class XSMBService_DeleteDirectory_pargs {
 public:


  virtual ~XSMBService_DeleteDirectory_pargs() throw();
  const std::string* dirPath;
  const bool* isRecursive;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_DeleteDirectory_result__isset {
  _XSMBService_DeleteDirectory_result__isset() : success(false) {}
  bool success :1;
} _XSMBService_DeleteDirectory_result__isset;

class XSMBService_DeleteDirectory_result {
 public:

  XSMBService_DeleteDirectory_result(const XSMBService_DeleteDirectory_result&);
  XSMBService_DeleteDirectory_result& operator=(const XSMBService_DeleteDirectory_result&);
  XSMBService_DeleteDirectory_result() : success(0) {
  }

  virtual ~XSMBService_DeleteDirectory_result() throw();
  bool success;

  _XSMBService_DeleteDirectory_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const XSMBService_DeleteDirectory_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteDirectory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteDirectory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_DeleteDirectory_presult__isset {
  _XSMBService_DeleteDirectory_presult__isset() : success(false) {}
  bool success :1;
} _XSMBService_DeleteDirectory_presult__isset;

class XSMBService_DeleteDirectory_presult {
 public:


  virtual ~XSMBService_DeleteDirectory_presult() throw();
  bool* success;

  _XSMBService_DeleteDirectory_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _XSMBService_CreateFile_args__isset {
  _XSMBService_CreateFile_args__isset() : filePath(false), fileSize(false), noBuffering(false) {}
  bool filePath :1;
  bool fileSize :1;
  bool noBuffering :1;
} _XSMBService_CreateFile_args__isset;

class XSMBService_CreateFile_args {
 public:

  XSMBService_CreateFile_args(const XSMBService_CreateFile_args&);
  XSMBService_CreateFile_args& operator=(const XSMBService_CreateFile_args&);
  XSMBService_CreateFile_args() : filePath(), fileSize(0), noBuffering(0) {
  }

  virtual ~XSMBService_CreateFile_args() throw();
  std::string filePath;
  int64_t fileSize;
  bool noBuffering;

  _XSMBService_CreateFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_fileSize(const int64_t val);

  void __set_noBuffering(const bool val);

  bool operator == (const XSMBService_CreateFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(fileSize == rhs.fileSize))
      return false;
    if (!(noBuffering == rhs.noBuffering))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class XSMBService_CreateFile_pargs {
 public:


  virtual ~XSMBService_CreateFile_pargs() throw();
  const std::string* filePath;
  const int64_t* fileSize;
  const bool* noBuffering;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_CreateFile_result__isset {
  _XSMBService_CreateFile_result__isset() : success(false) {}
  bool success :1;
} _XSMBService_CreateFile_result__isset;

class XSMBService_CreateFile_result {
 public:

  XSMBService_CreateFile_result(const XSMBService_CreateFile_result&);
  XSMBService_CreateFile_result& operator=(const XSMBService_CreateFile_result&);
  XSMBService_CreateFile_result() : success(0) {
  }

  virtual ~XSMBService_CreateFile_result() throw();
  bool success;

  _XSMBService_CreateFile_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const XSMBService_CreateFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const XSMBService_CreateFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_CreateFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_CreateFile_presult__isset {
  _XSMBService_CreateFile_presult__isset() : success(false) {}
  bool success :1;
} _XSMBService_CreateFile_presult__isset;

class XSMBService_CreateFile_presult {
 public:


  virtual ~XSMBService_CreateFile_presult() throw();
  bool* success;

  _XSMBService_CreateFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _XSMBService_DeleteFile_args__isset {
  _XSMBService_DeleteFile_args__isset() : filePath(false) {}
  bool filePath :1;
} _XSMBService_DeleteFile_args__isset;

class XSMBService_DeleteFile_args {
 public:

  XSMBService_DeleteFile_args(const XSMBService_DeleteFile_args&);
  XSMBService_DeleteFile_args& operator=(const XSMBService_DeleteFile_args&);
  XSMBService_DeleteFile_args() : filePath() {
  }

  virtual ~XSMBService_DeleteFile_args() throw();
  std::string filePath;

  _XSMBService_DeleteFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  bool operator == (const XSMBService_DeleteFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class XSMBService_DeleteFile_pargs {
 public:


  virtual ~XSMBService_DeleteFile_pargs() throw();
  const std::string* filePath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_DeleteFile_result__isset {
  _XSMBService_DeleteFile_result__isset() : success(false) {}
  bool success :1;
} _XSMBService_DeleteFile_result__isset;

class XSMBService_DeleteFile_result {
 public:

  XSMBService_DeleteFile_result(const XSMBService_DeleteFile_result&);
  XSMBService_DeleteFile_result& operator=(const XSMBService_DeleteFile_result&);
  XSMBService_DeleteFile_result() : success(0) {
  }

  virtual ~XSMBService_DeleteFile_result() throw();
  bool success;

  _XSMBService_DeleteFile_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const XSMBService_DeleteFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const XSMBService_DeleteFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_DeleteFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_DeleteFile_presult__isset {
  _XSMBService_DeleteFile_presult__isset() : success(false) {}
  bool success :1;
} _XSMBService_DeleteFile_presult__isset;

class XSMBService_DeleteFile_presult {
 public:


  virtual ~XSMBService_DeleteFile_presult() throw();
  bool* success;

  _XSMBService_DeleteFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _XSMBService_ReadFile_args__isset {
  _XSMBService_ReadFile_args__isset() : filePath(false), data(false), noBuffering(false), fileVersion(false), useVersionInData(false), keyName(false) {}
  bool filePath :1;
  bool data :1;
  bool noBuffering :1;
  bool fileVersion :1;
  bool useVersionInData :1;
  bool keyName :1;
} _XSMBService_ReadFile_args__isset;

class XSMBService_ReadFile_args {
 public:

  XSMBService_ReadFile_args(const XSMBService_ReadFile_args&);
  XSMBService_ReadFile_args& operator=(const XSMBService_ReadFile_args&);
  XSMBService_ReadFile_args() : filePath(), noBuffering(0), fileVersion(0), useVersionInData(0), keyName() {
  }

  virtual ~XSMBService_ReadFile_args() throw();
  std::string filePath;
  StreamDataLayout data;
  bool noBuffering;
  int8_t fileVersion;
  bool useVersionInData;
  std::string keyName;

  _XSMBService_ReadFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_data(const StreamDataLayout& val);

  void __set_noBuffering(const bool val);

  void __set_fileVersion(const int8_t val);

  void __set_useVersionInData(const bool val);

  void __set_keyName(const std::string& val);

  bool operator == (const XSMBService_ReadFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(noBuffering == rhs.noBuffering))
      return false;
    if (!(fileVersion == rhs.fileVersion))
      return false;
    if (!(useVersionInData == rhs.useVersionInData))
      return false;
    if (!(keyName == rhs.keyName))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ReadFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ReadFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class XSMBService_ReadFile_pargs {
 public:


  virtual ~XSMBService_ReadFile_pargs() throw();
  const std::string* filePath;
  const StreamDataLayout* data;
  const bool* noBuffering;
  const int8_t* fileVersion;
  const bool* useVersionInData;
  const std::string* keyName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_ReadFile_result__isset {
  _XSMBService_ReadFile_result__isset() : success(false) {}
  bool success :1;
} _XSMBService_ReadFile_result__isset;

class XSMBService_ReadFile_result {
 public:

  XSMBService_ReadFile_result(const XSMBService_ReadFile_result&);
  XSMBService_ReadFile_result& operator=(const XSMBService_ReadFile_result&);
  XSMBService_ReadFile_result() : success(0) {
  }

  virtual ~XSMBService_ReadFile_result() throw();
  bool success;

  _XSMBService_ReadFile_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const XSMBService_ReadFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ReadFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ReadFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_ReadFile_presult__isset {
  _XSMBService_ReadFile_presult__isset() : success(false) {}
  bool success :1;
} _XSMBService_ReadFile_presult__isset;

class XSMBService_ReadFile_presult {
 public:


  virtual ~XSMBService_ReadFile_presult() throw();
  bool* success;

  _XSMBService_ReadFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _XSMBService_WriteFile_args__isset {
  _XSMBService_WriteFile_args__isset() : filePath(false), data(false), noBuffering(false), fileVersion(false), useVersionInData(false), keyName(false) {}
  bool filePath :1;
  bool data :1;
  bool noBuffering :1;
  bool fileVersion :1;
  bool useVersionInData :1;
  bool keyName :1;
} _XSMBService_WriteFile_args__isset;

class XSMBService_WriteFile_args {
 public:

  XSMBService_WriteFile_args(const XSMBService_WriteFile_args&);
  XSMBService_WriteFile_args& operator=(const XSMBService_WriteFile_args&);
  XSMBService_WriteFile_args() : filePath(), noBuffering(0), fileVersion(0), useVersionInData(0), keyName() {
  }

  virtual ~XSMBService_WriteFile_args() throw();
  std::string filePath;
  StreamDataLayout data;
  bool noBuffering;
  int8_t fileVersion;
  bool useVersionInData;
  std::string keyName;

  _XSMBService_WriteFile_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_data(const StreamDataLayout& val);

  void __set_noBuffering(const bool val);

  void __set_fileVersion(const int8_t val);

  void __set_useVersionInData(const bool val);

  void __set_keyName(const std::string& val);

  bool operator == (const XSMBService_WriteFile_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(noBuffering == rhs.noBuffering))
      return false;
    if (!(fileVersion == rhs.fileVersion))
      return false;
    if (!(useVersionInData == rhs.useVersionInData))
      return false;
    if (!(keyName == rhs.keyName))
      return false;
    return true;
  }
  bool operator != (const XSMBService_WriteFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_WriteFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class XSMBService_WriteFile_pargs {
 public:


  virtual ~XSMBService_WriteFile_pargs() throw();
  const std::string* filePath;
  const StreamDataLayout* data;
  const bool* noBuffering;
  const int8_t* fileVersion;
  const bool* useVersionInData;
  const std::string* keyName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_WriteFile_result__isset {
  _XSMBService_WriteFile_result__isset() : success(false) {}
  bool success :1;
} _XSMBService_WriteFile_result__isset;

class XSMBService_WriteFile_result {
 public:

  XSMBService_WriteFile_result(const XSMBService_WriteFile_result&);
  XSMBService_WriteFile_result& operator=(const XSMBService_WriteFile_result&);
  XSMBService_WriteFile_result() : success(0) {
  }

  virtual ~XSMBService_WriteFile_result() throw();
  bool success;

  _XSMBService_WriteFile_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const XSMBService_WriteFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const XSMBService_WriteFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_WriteFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_WriteFile_presult__isset {
  _XSMBService_WriteFile_presult__isset() : success(false) {}
  bool success :1;
} _XSMBService_WriteFile_presult__isset;

class XSMBService_WriteFile_presult {
 public:


  virtual ~XSMBService_WriteFile_presult() throw();
  bool* success;

  _XSMBService_WriteFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _XSMBService_ListCloudFiles_args__isset {
  _XSMBService_ListCloudFiles_args__isset() : dirPath(false), isRecursive(false), files(false), dirs(false) {}
  bool dirPath :1;
  bool isRecursive :1;
  bool files :1;
  bool dirs :1;
} _XSMBService_ListCloudFiles_args__isset;

class XSMBService_ListCloudFiles_args {
 public:

  XSMBService_ListCloudFiles_args(const XSMBService_ListCloudFiles_args&);
  XSMBService_ListCloudFiles_args& operator=(const XSMBService_ListCloudFiles_args&);
  XSMBService_ListCloudFiles_args() : dirPath(), isRecursive(0) {
  }

  virtual ~XSMBService_ListCloudFiles_args() throw();
  std::string dirPath;
  bool isRecursive;
  std::map<std::string, MatchInformation::type>  files;
  std::map<std::string, MatchInformation::type>  dirs;

  _XSMBService_ListCloudFiles_args__isset __isset;

  void __set_dirPath(const std::string& val);

  void __set_isRecursive(const bool val);

  void __set_files(const std::map<std::string, MatchInformation::type> & val);

  void __set_dirs(const std::map<std::string, MatchInformation::type> & val);

  bool operator == (const XSMBService_ListCloudFiles_args & rhs) const
  {
    if (!(dirPath == rhs.dirPath))
      return false;
    if (!(isRecursive == rhs.isRecursive))
      return false;
    if (!(files == rhs.files))
      return false;
    if (!(dirs == rhs.dirs))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ListCloudFiles_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ListCloudFiles_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class XSMBService_ListCloudFiles_pargs {
 public:


  virtual ~XSMBService_ListCloudFiles_pargs() throw();
  const std::string* dirPath;
  const bool* isRecursive;
  const std::map<std::string, MatchInformation::type> * files;
  const std::map<std::string, MatchInformation::type> * dirs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_ListCloudFiles_result__isset {
  _XSMBService_ListCloudFiles_result__isset() : success(false) {}
  bool success :1;
} _XSMBService_ListCloudFiles_result__isset;

class XSMBService_ListCloudFiles_result {
 public:

  XSMBService_ListCloudFiles_result(const XSMBService_ListCloudFiles_result&);
  XSMBService_ListCloudFiles_result& operator=(const XSMBService_ListCloudFiles_result&);
  XSMBService_ListCloudFiles_result() : success(0) {
  }

  virtual ~XSMBService_ListCloudFiles_result() throw();
  bool success;

  _XSMBService_ListCloudFiles_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const XSMBService_ListCloudFiles_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const XSMBService_ListCloudFiles_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_ListCloudFiles_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_ListCloudFiles_presult__isset {
  _XSMBService_ListCloudFiles_presult__isset() : success(false) {}
  bool success :1;
} _XSMBService_ListCloudFiles_presult__isset;

class XSMBService_ListCloudFiles_presult {
 public:


  virtual ~XSMBService_ListCloudFiles_presult() throw();
  bool* success;

  _XSMBService_ListCloudFiles_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _XSMBService_GetCloudFileLength_args__isset {
  _XSMBService_GetCloudFileLength_args__isset() : filePath(false) {}
  bool filePath :1;
} _XSMBService_GetCloudFileLength_args__isset;

class XSMBService_GetCloudFileLength_args {
 public:

  XSMBService_GetCloudFileLength_args(const XSMBService_GetCloudFileLength_args&);
  XSMBService_GetCloudFileLength_args& operator=(const XSMBService_GetCloudFileLength_args&);
  XSMBService_GetCloudFileLength_args() : filePath() {
  }

  virtual ~XSMBService_GetCloudFileLength_args() throw();
  std::string filePath;

  _XSMBService_GetCloudFileLength_args__isset __isset;

  void __set_filePath(const std::string& val);

  bool operator == (const XSMBService_GetCloudFileLength_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    return true;
  }
  bool operator != (const XSMBService_GetCloudFileLength_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_GetCloudFileLength_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class XSMBService_GetCloudFileLength_pargs {
 public:


  virtual ~XSMBService_GetCloudFileLength_pargs() throw();
  const std::string* filePath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_GetCloudFileLength_result__isset {
  _XSMBService_GetCloudFileLength_result__isset() : success(false) {}
  bool success :1;
} _XSMBService_GetCloudFileLength_result__isset;

class XSMBService_GetCloudFileLength_result {
 public:

  XSMBService_GetCloudFileLength_result(const XSMBService_GetCloudFileLength_result&);
  XSMBService_GetCloudFileLength_result& operator=(const XSMBService_GetCloudFileLength_result&);
  XSMBService_GetCloudFileLength_result() : success(0) {
  }

  virtual ~XSMBService_GetCloudFileLength_result() throw();
  int64_t success;

  _XSMBService_GetCloudFileLength_result__isset __isset;

  void __set_success(const int64_t val);

  bool operator == (const XSMBService_GetCloudFileLength_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const XSMBService_GetCloudFileLength_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_GetCloudFileLength_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_GetCloudFileLength_presult__isset {
  _XSMBService_GetCloudFileLength_presult__isset() : success(false) {}
  bool success :1;
} _XSMBService_GetCloudFileLength_presult__isset;

class XSMBService_GetCloudFileLength_presult {
 public:


  virtual ~XSMBService_GetCloudFileLength_presult() throw();
  int64_t* success;

  _XSMBService_GetCloudFileLength_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _XSMBService_SetCloudFileLength_args__isset {
  _XSMBService_SetCloudFileLength_args__isset() : filePath(false), fileLength(false) {}
  bool filePath :1;
  bool fileLength :1;
} _XSMBService_SetCloudFileLength_args__isset;

class XSMBService_SetCloudFileLength_args {
 public:

  XSMBService_SetCloudFileLength_args(const XSMBService_SetCloudFileLength_args&);
  XSMBService_SetCloudFileLength_args& operator=(const XSMBService_SetCloudFileLength_args&);
  XSMBService_SetCloudFileLength_args() : filePath(), fileLength(0) {
  }

  virtual ~XSMBService_SetCloudFileLength_args() throw();
  std::string filePath;
  int64_t fileLength;

  _XSMBService_SetCloudFileLength_args__isset __isset;

  void __set_filePath(const std::string& val);

  void __set_fileLength(const int64_t val);

  bool operator == (const XSMBService_SetCloudFileLength_args & rhs) const
  {
    if (!(filePath == rhs.filePath))
      return false;
    if (!(fileLength == rhs.fileLength))
      return false;
    return true;
  }
  bool operator != (const XSMBService_SetCloudFileLength_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_SetCloudFileLength_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class XSMBService_SetCloudFileLength_pargs {
 public:


  virtual ~XSMBService_SetCloudFileLength_pargs() throw();
  const std::string* filePath;
  const int64_t* fileLength;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_SetCloudFileLength_result__isset {
  _XSMBService_SetCloudFileLength_result__isset() : success(false) {}
  bool success :1;
} _XSMBService_SetCloudFileLength_result__isset;

class XSMBService_SetCloudFileLength_result {
 public:

  XSMBService_SetCloudFileLength_result(const XSMBService_SetCloudFileLength_result&);
  XSMBService_SetCloudFileLength_result& operator=(const XSMBService_SetCloudFileLength_result&);
  XSMBService_SetCloudFileLength_result() : success(0) {
  }

  virtual ~XSMBService_SetCloudFileLength_result() throw();
  bool success;

  _XSMBService_SetCloudFileLength_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const XSMBService_SetCloudFileLength_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const XSMBService_SetCloudFileLength_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XSMBService_SetCloudFileLength_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _XSMBService_SetCloudFileLength_presult__isset {
  _XSMBService_SetCloudFileLength_presult__isset() : success(false) {}
  bool success :1;
} _XSMBService_SetCloudFileLength_presult__isset;

class XSMBService_SetCloudFileLength_presult {
 public:


  virtual ~XSMBService_SetCloudFileLength_presult() throw();
  bool* success;

  _XSMBService_SetCloudFileLength_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class XSMBServiceClient : virtual public XSMBServiceIf {
 public:
  XSMBServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  XSMBServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool CreateDirectory(const std::string& dirPath);
  void send_CreateDirectory(const std::string& dirPath);
  bool recv_CreateDirectory();
  bool DeleteDirectory(const std::string& dirPath, const bool isRecursive);
  void send_DeleteDirectory(const std::string& dirPath, const bool isRecursive);
  bool recv_DeleteDirectory();
  bool CreateFile(const std::string& filePath, const int64_t fileSize, const bool noBuffering);
  void send_CreateFile(const std::string& filePath, const int64_t fileSize, const bool noBuffering);
  bool recv_CreateFile();
  bool DeleteFile(const std::string& filePath);
  void send_DeleteFile(const std::string& filePath);
  bool recv_DeleteFile();
  bool ReadFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  void send_ReadFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  bool recv_ReadFile();
  bool WriteFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  void send_WriteFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  bool recv_WriteFile();
  bool ListCloudFiles(const std::string& dirPath, const bool isRecursive, const std::map<std::string, MatchInformation::type> & files, const std::map<std::string, MatchInformation::type> & dirs);
  void send_ListCloudFiles(const std::string& dirPath, const bool isRecursive, const std::map<std::string, MatchInformation::type> & files, const std::map<std::string, MatchInformation::type> & dirs);
  bool recv_ListCloudFiles();
  int64_t GetCloudFileLength(const std::string& filePath);
  void send_GetCloudFileLength(const std::string& filePath);
  int64_t recv_GetCloudFileLength();
  bool SetCloudFileLength(const std::string& filePath, const int64_t fileLength);
  void send_SetCloudFileLength(const std::string& filePath, const int64_t fileLength);
  bool recv_SetCloudFileLength();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class XSMBServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<XSMBServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (XSMBServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_CreateDirectory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_DeleteDirectory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_CreateFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_DeleteFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ReadFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_WriteFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ListCloudFiles(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetCloudFileLength(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SetCloudFileLength(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  XSMBServiceProcessor(boost::shared_ptr<XSMBServiceIf> iface) :
    iface_(iface) {
    processMap_["CreateDirectory"] = &XSMBServiceProcessor::process_CreateDirectory;
    processMap_["DeleteDirectory"] = &XSMBServiceProcessor::process_DeleteDirectory;
    processMap_["CreateFile"] = &XSMBServiceProcessor::process_CreateFile;
    processMap_["DeleteFile"] = &XSMBServiceProcessor::process_DeleteFile;
    processMap_["ReadFile"] = &XSMBServiceProcessor::process_ReadFile;
    processMap_["WriteFile"] = &XSMBServiceProcessor::process_WriteFile;
    processMap_["ListCloudFiles"] = &XSMBServiceProcessor::process_ListCloudFiles;
    processMap_["GetCloudFileLength"] = &XSMBServiceProcessor::process_GetCloudFileLength;
    processMap_["SetCloudFileLength"] = &XSMBServiceProcessor::process_SetCloudFileLength;
  }

  virtual ~XSMBServiceProcessor() {}
};

class XSMBServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  XSMBServiceProcessorFactory(const ::boost::shared_ptr< XSMBServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< XSMBServiceIfFactory > handlerFactory_;
};

class XSMBServiceMultiface : virtual public XSMBServiceIf {
 public:
  XSMBServiceMultiface(std::vector<boost::shared_ptr<XSMBServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~XSMBServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<XSMBServiceIf> > ifaces_;
  XSMBServiceMultiface() {}
  void add(boost::shared_ptr<XSMBServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  bool CreateDirectory(const std::string& dirPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->CreateDirectory(dirPath);
    }
    return ifaces_[i]->CreateDirectory(dirPath);
  }

  bool DeleteDirectory(const std::string& dirPath, const bool isRecursive) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->DeleteDirectory(dirPath, isRecursive);
    }
    return ifaces_[i]->DeleteDirectory(dirPath, isRecursive);
  }

  bool CreateFile(const std::string& filePath, const int64_t fileSize, const bool noBuffering) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->CreateFile(filePath, fileSize, noBuffering);
    }
    return ifaces_[i]->CreateFile(filePath, fileSize, noBuffering);
  }

  bool DeleteFile(const std::string& filePath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->DeleteFile(filePath);
    }
    return ifaces_[i]->DeleteFile(filePath);
  }

  bool ReadFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ReadFile(filePath, data, noBuffering, fileVersion, useVersionInData, keyName);
    }
    return ifaces_[i]->ReadFile(filePath, data, noBuffering, fileVersion, useVersionInData, keyName);
  }

  bool WriteFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->WriteFile(filePath, data, noBuffering, fileVersion, useVersionInData, keyName);
    }
    return ifaces_[i]->WriteFile(filePath, data, noBuffering, fileVersion, useVersionInData, keyName);
  }

  bool ListCloudFiles(const std::string& dirPath, const bool isRecursive, const std::map<std::string, MatchInformation::type> & files, const std::map<std::string, MatchInformation::type> & dirs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ListCloudFiles(dirPath, isRecursive, files, dirs);
    }
    return ifaces_[i]->ListCloudFiles(dirPath, isRecursive, files, dirs);
  }

  int64_t GetCloudFileLength(const std::string& filePath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetCloudFileLength(filePath);
    }
    return ifaces_[i]->GetCloudFileLength(filePath);
  }

  bool SetCloudFileLength(const std::string& filePath, const int64_t fileLength) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SetCloudFileLength(filePath, fileLength);
    }
    return ifaces_[i]->SetCloudFileLength(filePath, fileLength);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class XSMBServiceConcurrentClient : virtual public XSMBServiceIf {
 public:
  XSMBServiceConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  XSMBServiceConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool CreateDirectory(const std::string& dirPath);
  int32_t send_CreateDirectory(const std::string& dirPath);
  bool recv_CreateDirectory(const int32_t seqid);
  bool DeleteDirectory(const std::string& dirPath, const bool isRecursive);
  int32_t send_DeleteDirectory(const std::string& dirPath, const bool isRecursive);
  bool recv_DeleteDirectory(const int32_t seqid);
  bool CreateFile(const std::string& filePath, const int64_t fileSize, const bool noBuffering);
  int32_t send_CreateFile(const std::string& filePath, const int64_t fileSize, const bool noBuffering);
  bool recv_CreateFile(const int32_t seqid);
  bool DeleteFile(const std::string& filePath);
  int32_t send_DeleteFile(const std::string& filePath);
  bool recv_DeleteFile(const int32_t seqid);
  bool ReadFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  int32_t send_ReadFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  bool recv_ReadFile(const int32_t seqid);
  bool WriteFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  int32_t send_WriteFile(const std::string& filePath, const StreamDataLayout& data, const bool noBuffering, const int8_t fileVersion, const bool useVersionInData, const std::string& keyName);
  bool recv_WriteFile(const int32_t seqid);
  bool ListCloudFiles(const std::string& dirPath, const bool isRecursive, const std::map<std::string, MatchInformation::type> & files, const std::map<std::string, MatchInformation::type> & dirs);
  int32_t send_ListCloudFiles(const std::string& dirPath, const bool isRecursive, const std::map<std::string, MatchInformation::type> & files, const std::map<std::string, MatchInformation::type> & dirs);
  bool recv_ListCloudFiles(const int32_t seqid);
  int64_t GetCloudFileLength(const std::string& filePath);
  int32_t send_GetCloudFileLength(const std::string& filePath);
  int64_t recv_GetCloudFileLength(const int32_t seqid);
  bool SetCloudFileLength(const std::string& filePath, const int64_t fileLength);
  int32_t send_SetCloudFileLength(const std::string& filePath, const int64_t fileLength);
  bool recv_SetCloudFileLength(const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif

}}} // namespace

#endif
